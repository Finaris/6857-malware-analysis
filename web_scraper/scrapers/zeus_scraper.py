# -*- coding: utf-8 -*-
"""

This module implements the Scraper interface for
Zeus for data mining purposes.

"""

import logging
import os

from bs4 import BeautifulSoup
from datetime import datetime
from typing import Dict, List

from scraper import Category, RecordAttribute, Scraper


class ZeusScraper(Scraper):
    """ Implementation of Scraper for Zeus. """

    def __init__(self):
        # Specify the URL of Zeus and the pages we are scanning.
        self.short_name = "zeus"
        self.base_url = "https://zeustracker.abuse.ch/"
        self.pages_scraped = ["monitor.php?browse=binaries"]
        super().__init__(self.short_name, self.base_url, self.pages_scraped)

        # Set and clear the remaining class attributes.
        self.base_path = os.path.dirname(os.path.realpath(__file__)) + "/persistent_data/zeus/"
        self.files = os.listdir(self.base_path)
        self.records = {}
        self.timestamp = None

    def scrape(self):
        # Before beginning, clear all records and update the timestamp.
        self.records = {}
        self.timestamp = datetime.now()

        # Process data from the stored files.
        for file in self.files:
            self.records[file] = self._process_file(file)

        # Process data from the online page(s).
        for page_name in self.pages_scraped:
            # Get a response from making a request to the page and only proceed if the request worked.
            url = self.base_url + page_name
            response, is_ok = self.make_request(url)
            if not is_ok:
                continue

            # Parse the response's content and store the records.
            html = BeautifulSoup(response.content, 'html.parser')
            self.records[page_name] = self._generate_records(url, html)
        logging.info("Completed scraping {0}".format(self.short_name))

    def _process_file(self, file: str) -> List[Dict]:
        """ Processes a single file in the directory.

        :param file: (str) Path to a file to open.
        :return: (list) Dictionary records gained from the file.
        """
        with open(self.base_path + file, encoding='latin-1') as hosts_file:
            records = []
            for line in hosts_file.readlines():
                line_contents = line.strip().split()
                if line_contents and line_contents[0][0] != "#":
                    new_record = {
                        RecordAttribute.CATEGORY: Category.GENERAL_MALWARE
                    }
                    if self.is_url_ip_address(line_contents[0]):
                        new_record[RecordAttribute.IP] = line_contents[0]
                    else:
                        new_record[RecordAttribute.URL] = line_contents[0]
                    records.append(new_record)
            return records

    @staticmethod
    def _generate_records(url: str, html: BeautifulSoup) -> List[Dict]:
        """ Given a Zeus HTML page from the database, generate a list of records.

        :param url: (str) The current URL being viewed.
        :param html: (BeautifulSoup) HTML response from malc0de.
        :return: (list) A list of record dictionaries.
        """
        # Fetch the information table and all of its rows (exclude the header row).
        records = []
        for tr in html.select("tr")[1:]:
            # Find all tabular data. This isn't a strong check, but make sure the data is how we expect it.
            td = tr.find_all("td")
            if len(td) != 8:
                logging.error("Data not formatted as expected for component in {0}".format(url))
                continue

            # Load information from the tabular data. This has downloads too which is cool.
            date = str(datetime.strptime(td[0].text, "%Y-%m-%d"))
            malware_url = td[1].text.strip()
            status = td[2].text
            md5 = td[3].text

            # Store all of the loaded information into a new record.
            records.append({
                RecordAttribute.DATE: date,
                RecordAttribute.URL: malware_url,
                RecordAttribute.STATUS: status,
                RecordAttribute.MD5: md5,
                RecordAttribute.CATEGORY: Category.GENERAL_MALWARE
            })
        return records
